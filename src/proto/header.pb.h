// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/header.proto

#ifndef PROTOBUF_proto_2fheader_2eproto__INCLUDED
#define PROTOBUF_proto_2fheader_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "proto/nodemgt.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_proto_2fheader_2eproto();
void protobuf_AssignDesc_proto_2fheader_2eproto();
void protobuf_ShutdownFile_proto_2fheader_2eproto();

class Header;
class Header_ApplyFlag;
class Header_KeyFlag;
class Header_ValueFlag;
class Header_ReplicaInfo;

enum Header_Type {
  Header_Type_INVALID_TYPE = 0,
  Header_Type_PUSH = 1,
  Header_Type_PULL = 2,
  Header_Type_PUSH_PULL = 3,
  Header_Type_REPLY = 4,
  Header_Type_DUPLICATE = 8,
  Header_Type_BACKUP = 16,
  Header_Type_NODE_RESCUE = 32
};
bool Header_Type_IsValid(int value);
const Header_Type Header_Type_Type_MIN = Header_Type_INVALID_TYPE;
const Header_Type Header_Type_Type_MAX = Header_Type_NODE_RESCUE;
const int Header_Type_Type_ARRAYSIZE = Header_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Header_Type_descriptor();
inline const ::std::string& Header_Type_Name(Header_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Header_Type_descriptor(), value);
}
inline bool Header_Type_Parse(
    const ::std::string& name, Header_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Header_Type>(
    Header_Type_descriptor(), name, value);
}
// ===================================================================

class Header_ApplyFlag : public ::google::protobuf::Message {
 public:
  Header_ApplyFlag();
  virtual ~Header_ApplyFlag();

  Header_ApplyFlag(const Header_ApplyFlag& from);

  inline Header_ApplyFlag& operator=(const Header_ApplyFlag& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Header_ApplyFlag& default_instance();

  void Swap(Header_ApplyFlag* other);

  // implements Message ----------------------------------------------

  Header_ApplyFlag* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Header_ApplyFlag& from);
  void MergeFrom(const Header_ApplyFlag& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool delta = 1;
  inline bool has_delta() const;
  inline void clear_delta();
  static const int kDeltaFieldNumber = 1;
  inline bool delta() const;
  inline void set_delta(bool value);

  // repeated int32 vectors = 2 [packed = true];
  inline int vectors_size() const;
  inline void clear_vectors();
  static const int kVectorsFieldNumber = 2;
  inline ::google::protobuf::int32 vectors(int index) const;
  inline void set_vectors(int index, ::google::protobuf::int32 value);
  inline void add_vectors(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      vectors() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_vectors();

  // @@protoc_insertion_point(class_scope:Header.ApplyFlag)
 private:
  inline void set_has_delta();
  inline void clear_has_delta();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > vectors_;
  mutable int _vectors_cached_byte_size_;
  bool delta_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_proto_2fheader_2eproto();
  friend void protobuf_AssignDesc_proto_2fheader_2eproto();
  friend void protobuf_ShutdownFile_proto_2fheader_2eproto();

  void InitAsDefaultInstance();
  static Header_ApplyFlag* default_instance_;
};
// -------------------------------------------------------------------

class Header_KeyFlag : public ::google::protobuf::Message {
 public:
  Header_KeyFlag();
  virtual ~Header_KeyFlag();

  Header_KeyFlag(const Header_KeyFlag& from);

  inline Header_KeyFlag& operator=(const Header_KeyFlag& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Header_KeyFlag& default_instance();

  void Swap(Header_KeyFlag* other);

  // implements Message ----------------------------------------------

  Header_KeyFlag* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Header_KeyFlag& from);
  void MergeFrom(const Header_KeyFlag& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool empty = 1;
  inline bool has_empty() const;
  inline void clear_empty();
  static const int kEmptyFieldNumber = 1;
  inline bool empty() const;
  inline void set_empty(bool value);

  // required uint64 start = 2;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 2;
  inline ::google::protobuf::uint64 start() const;
  inline void set_start(::google::protobuf::uint64 value);

  // required uint64 end = 3;
  inline bool has_end() const;
  inline void clear_end();
  static const int kEndFieldNumber = 3;
  inline ::google::protobuf::uint64 end() const;
  inline void set_end(::google::protobuf::uint64 value);

  // required fixed32 cksum = 4;
  inline bool has_cksum() const;
  inline void clear_cksum();
  static const int kCksumFieldNumber = 4;
  inline ::google::protobuf::uint32 cksum() const;
  inline void set_cksum(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Header.KeyFlag)
 private:
  inline void set_has_empty();
  inline void clear_has_empty();
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_end();
  inline void clear_has_end();
  inline void set_has_cksum();
  inline void clear_has_cksum();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 start_;
  bool empty_;
  ::google::protobuf::uint32 cksum_;
  ::google::protobuf::uint64 end_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_proto_2fheader_2eproto();
  friend void protobuf_AssignDesc_proto_2fheader_2eproto();
  friend void protobuf_ShutdownFile_proto_2fheader_2eproto();

  void InitAsDefaultInstance();
  static Header_KeyFlag* default_instance_;
};
// -------------------------------------------------------------------

class Header_ValueFlag : public ::google::protobuf::Message {
 public:
  Header_ValueFlag();
  virtual ~Header_ValueFlag();

  Header_ValueFlag(const Header_ValueFlag& from);

  inline Header_ValueFlag& operator=(const Header_ValueFlag& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Header_ValueFlag& default_instance();

  void Swap(Header_ValueFlag* other);

  // implements Message ----------------------------------------------

  Header_ValueFlag* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Header_ValueFlag& from);
  void MergeFrom(const Header_ValueFlag& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool empty = 1;
  inline bool has_empty() const;
  inline void clear_empty();
  static const int kEmptyFieldNumber = 1;
  inline bool empty() const;
  inline void set_empty(bool value);

  // optional double eps = 2;
  inline bool has_eps() const;
  inline void clear_eps();
  static const int kEpsFieldNumber = 2;
  inline double eps() const;
  inline void set_eps(double value);

  // @@protoc_insertion_point(class_scope:Header.ValueFlag)
 private:
  inline void set_has_empty();
  inline void clear_has_empty();
  inline void set_has_eps();
  inline void clear_has_eps();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double eps_;
  bool empty_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_proto_2fheader_2eproto();
  friend void protobuf_AssignDesc_proto_2fheader_2eproto();
  friend void protobuf_ShutdownFile_proto_2fheader_2eproto();

  void InitAsDefaultInstance();
  static Header_ValueFlag* default_instance_;
};
// -------------------------------------------------------------------

class Header_ReplicaInfo : public ::google::protobuf::Message {
 public:
  Header_ReplicaInfo();
  virtual ~Header_ReplicaInfo();

  Header_ReplicaInfo(const Header_ReplicaInfo& from);

  inline Header_ReplicaInfo& operator=(const Header_ReplicaInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Header_ReplicaInfo& default_instance();

  void Swap(Header_ReplicaInfo* other);

  // implements Message ----------------------------------------------

  Header_ReplicaInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Header_ReplicaInfo& from);
  void MergeFrom(const Header_ReplicaInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline ::google::protobuf::int32 node_id() const;
  inline void set_node_id(::google::protobuf::int32 value);

  // required int32 replica_id = 3;
  inline bool has_replica_id() const;
  inline void clear_replica_id();
  static const int kReplicaIdFieldNumber = 3;
  inline ::google::protobuf::int32 replica_id() const;
  inline void set_replica_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Header.ReplicaInfo)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();
  inline void set_has_replica_id();
  inline void clear_has_replica_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 node_id_;
  ::google::protobuf::int32 replica_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_proto_2fheader_2eproto();
  friend void protobuf_AssignDesc_proto_2fheader_2eproto();
  friend void protobuf_ShutdownFile_proto_2fheader_2eproto();

  void InitAsDefaultInstance();
  static Header_ReplicaInfo* default_instance_;
};
// -------------------------------------------------------------------

class Header : public ::google::protobuf::Message {
 public:
  Header();
  virtual ~Header();

  Header(const Header& from);

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Header& default_instance();

  void Swap(Header* other);

  // implements Message ----------------------------------------------

  Header* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Header& from);
  void MergeFrom(const Header& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Header_ApplyFlag ApplyFlag;
  typedef Header_KeyFlag KeyFlag;
  typedef Header_ValueFlag ValueFlag;
  typedef Header_ReplicaInfo ReplicaInfo;

  typedef Header_Type Type;
  static const Type INVALID_TYPE = Header_Type_INVALID_TYPE;
  static const Type PUSH = Header_Type_PUSH;
  static const Type PULL = Header_Type_PULL;
  static const Type PUSH_PULL = Header_Type_PUSH_PULL;
  static const Type REPLY = Header_Type_REPLY;
  static const Type DUPLICATE = Header_Type_DUPLICATE;
  static const Type BACKUP = Header_Type_BACKUP;
  static const Type NODE_RESCUE = Header_Type_NODE_RESCUE;
  static inline bool Type_IsValid(int value) {
    return Header_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Header_Type_Type_MIN;
  static const Type Type_MAX =
    Header_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Header_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Header_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Header_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Header_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .Header.Type type = 1 [default = INVALID_TYPE];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::Header_Type type() const;
  inline void set_type(::Header_Type value);

  // required int32 sender = 2;
  inline bool has_sender() const;
  inline void clear_sender();
  static const int kSenderFieldNumber = 2;
  inline ::google::protobuf::int32 sender() const;
  inline void set_sender(::google::protobuf::int32 value);

  // required int32 recver = 3;
  inline bool has_recver() const;
  inline void clear_recver();
  static const int kRecverFieldNumber = 3;
  inline ::google::protobuf::int32 recver() const;
  inline void set_recver(::google::protobuf::int32 value);

  // required string name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 time = 5;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 5;
  inline ::google::protobuf::int32 time() const;
  inline void set_time(::google::protobuf::int32 value);

  // optional .Header.ApplyFlag push = 6;
  inline bool has_push() const;
  inline void clear_push();
  static const int kPushFieldNumber = 6;
  inline const ::Header_ApplyFlag& push() const;
  inline ::Header_ApplyFlag* mutable_push();
  inline ::Header_ApplyFlag* release_push();
  inline void set_allocated_push(::Header_ApplyFlag* push);

  // optional .Header.ApplyFlag pull = 7;
  inline bool has_pull() const;
  inline void clear_pull();
  static const int kPullFieldNumber = 7;
  inline const ::Header_ApplyFlag& pull() const;
  inline ::Header_ApplyFlag* mutable_pull();
  inline ::Header_ApplyFlag* release_pull();
  inline void set_allocated_pull(::Header_ApplyFlag* pull);

  // optional .Header.KeyFlag key = 8;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 8;
  inline const ::Header_KeyFlag& key() const;
  inline ::Header_KeyFlag* mutable_key();
  inline ::Header_KeyFlag* release_key();
  inline void set_allocated_key(::Header_KeyFlag* key);

  // optional .Header.ValueFlag value = 9;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 9;
  inline const ::Header_ValueFlag& value() const;
  inline ::Header_ValueFlag* mutable_value();
  inline ::Header_ValueFlag* release_value();
  inline void set_allocated_value(::Header_ValueFlag* value);

  // optional .Header.ReplicaInfo replica_info = 10;
  inline bool has_replica_info() const;
  inline void clear_replica_info();
  static const int kReplicaInfoFieldNumber = 10;
  inline const ::Header_ReplicaInfo& replica_info() const;
  inline ::Header_ReplicaInfo* mutable_replica_info();
  inline ::Header_ReplicaInfo* release_replica_info();
  inline void set_allocated_replica_info(::Header_ReplicaInfo* replica_info);

  // @@protoc_insertion_point(class_scope:Header)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_sender();
  inline void clear_has_sender();
  inline void set_has_recver();
  inline void clear_has_recver();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_push();
  inline void clear_has_push();
  inline void set_has_pull();
  inline void clear_has_pull();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_replica_info();
  inline void clear_has_replica_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  ::google::protobuf::int32 sender_;
  ::std::string* name_;
  ::google::protobuf::int32 recver_;
  ::google::protobuf::int32 time_;
  ::Header_ApplyFlag* push_;
  ::Header_ApplyFlag* pull_;
  ::Header_KeyFlag* key_;
  ::Header_ValueFlag* value_;
  ::Header_ReplicaInfo* replica_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_proto_2fheader_2eproto();
  friend void protobuf_AssignDesc_proto_2fheader_2eproto();
  friend void protobuf_ShutdownFile_proto_2fheader_2eproto();

  void InitAsDefaultInstance();
  static Header* default_instance_;
};
// ===================================================================


// ===================================================================

// Header_ApplyFlag

// required bool delta = 1;
inline bool Header_ApplyFlag::has_delta() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Header_ApplyFlag::set_has_delta() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Header_ApplyFlag::clear_has_delta() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Header_ApplyFlag::clear_delta() {
  delta_ = false;
  clear_has_delta();
}
inline bool Header_ApplyFlag::delta() const {
  return delta_;
}
inline void Header_ApplyFlag::set_delta(bool value) {
  set_has_delta();
  delta_ = value;
}

// repeated int32 vectors = 2 [packed = true];
inline int Header_ApplyFlag::vectors_size() const {
  return vectors_.size();
}
inline void Header_ApplyFlag::clear_vectors() {
  vectors_.Clear();
}
inline ::google::protobuf::int32 Header_ApplyFlag::vectors(int index) const {
  return vectors_.Get(index);
}
inline void Header_ApplyFlag::set_vectors(int index, ::google::protobuf::int32 value) {
  vectors_.Set(index, value);
}
inline void Header_ApplyFlag::add_vectors(::google::protobuf::int32 value) {
  vectors_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Header_ApplyFlag::vectors() const {
  return vectors_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Header_ApplyFlag::mutable_vectors() {
  return &vectors_;
}

// -------------------------------------------------------------------

// Header_KeyFlag

// required bool empty = 1;
inline bool Header_KeyFlag::has_empty() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Header_KeyFlag::set_has_empty() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Header_KeyFlag::clear_has_empty() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Header_KeyFlag::clear_empty() {
  empty_ = false;
  clear_has_empty();
}
inline bool Header_KeyFlag::empty() const {
  return empty_;
}
inline void Header_KeyFlag::set_empty(bool value) {
  set_has_empty();
  empty_ = value;
}

// required uint64 start = 2;
inline bool Header_KeyFlag::has_start() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Header_KeyFlag::set_has_start() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Header_KeyFlag::clear_has_start() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Header_KeyFlag::clear_start() {
  start_ = GOOGLE_ULONGLONG(0);
  clear_has_start();
}
inline ::google::protobuf::uint64 Header_KeyFlag::start() const {
  return start_;
}
inline void Header_KeyFlag::set_start(::google::protobuf::uint64 value) {
  set_has_start();
  start_ = value;
}

// required uint64 end = 3;
inline bool Header_KeyFlag::has_end() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Header_KeyFlag::set_has_end() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Header_KeyFlag::clear_has_end() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Header_KeyFlag::clear_end() {
  end_ = GOOGLE_ULONGLONG(0);
  clear_has_end();
}
inline ::google::protobuf::uint64 Header_KeyFlag::end() const {
  return end_;
}
inline void Header_KeyFlag::set_end(::google::protobuf::uint64 value) {
  set_has_end();
  end_ = value;
}

// required fixed32 cksum = 4;
inline bool Header_KeyFlag::has_cksum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Header_KeyFlag::set_has_cksum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Header_KeyFlag::clear_has_cksum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Header_KeyFlag::clear_cksum() {
  cksum_ = 0u;
  clear_has_cksum();
}
inline ::google::protobuf::uint32 Header_KeyFlag::cksum() const {
  return cksum_;
}
inline void Header_KeyFlag::set_cksum(::google::protobuf::uint32 value) {
  set_has_cksum();
  cksum_ = value;
}

// -------------------------------------------------------------------

// Header_ValueFlag

// required bool empty = 1;
inline bool Header_ValueFlag::has_empty() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Header_ValueFlag::set_has_empty() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Header_ValueFlag::clear_has_empty() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Header_ValueFlag::clear_empty() {
  empty_ = false;
  clear_has_empty();
}
inline bool Header_ValueFlag::empty() const {
  return empty_;
}
inline void Header_ValueFlag::set_empty(bool value) {
  set_has_empty();
  empty_ = value;
}

// optional double eps = 2;
inline bool Header_ValueFlag::has_eps() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Header_ValueFlag::set_has_eps() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Header_ValueFlag::clear_has_eps() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Header_ValueFlag::clear_eps() {
  eps_ = 0;
  clear_has_eps();
}
inline double Header_ValueFlag::eps() const {
  return eps_;
}
inline void Header_ValueFlag::set_eps(double value) {
  set_has_eps();
  eps_ = value;
}

// -------------------------------------------------------------------

// Header_ReplicaInfo

// required int32 node_id = 1;
inline bool Header_ReplicaInfo::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Header_ReplicaInfo::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Header_ReplicaInfo::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Header_ReplicaInfo::clear_node_id() {
  node_id_ = 0;
  clear_has_node_id();
}
inline ::google::protobuf::int32 Header_ReplicaInfo::node_id() const {
  return node_id_;
}
inline void Header_ReplicaInfo::set_node_id(::google::protobuf::int32 value) {
  set_has_node_id();
  node_id_ = value;
}

// required int32 replica_id = 3;
inline bool Header_ReplicaInfo::has_replica_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Header_ReplicaInfo::set_has_replica_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Header_ReplicaInfo::clear_has_replica_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Header_ReplicaInfo::clear_replica_id() {
  replica_id_ = 0;
  clear_has_replica_id();
}
inline ::google::protobuf::int32 Header_ReplicaInfo::replica_id() const {
  return replica_id_;
}
inline void Header_ReplicaInfo::set_replica_id(::google::protobuf::int32 value) {
  set_has_replica_id();
  replica_id_ = value;
}

// -------------------------------------------------------------------

// Header

// required .Header.Type type = 1 [default = INVALID_TYPE];
inline bool Header::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Header::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Header::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Header::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::Header_Type Header::type() const {
  return static_cast< ::Header_Type >(type_);
}
inline void Header::set_type(::Header_Type value) {
  assert(::Header_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// required int32 sender = 2;
inline bool Header::has_sender() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Header::set_has_sender() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Header::clear_has_sender() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Header::clear_sender() {
  sender_ = 0;
  clear_has_sender();
}
inline ::google::protobuf::int32 Header::sender() const {
  return sender_;
}
inline void Header::set_sender(::google::protobuf::int32 value) {
  set_has_sender();
  sender_ = value;
}

// required int32 recver = 3;
inline bool Header::has_recver() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Header::set_has_recver() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Header::clear_has_recver() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Header::clear_recver() {
  recver_ = 0;
  clear_has_recver();
}
inline ::google::protobuf::int32 Header::recver() const {
  return recver_;
}
inline void Header::set_recver(::google::protobuf::int32 value) {
  set_has_recver();
  recver_ = value;
}

// required string name = 4;
inline bool Header::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Header::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Header::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Header::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Header::name() const {
  return *name_;
}
inline void Header::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Header::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Header::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Header::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Header::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Header::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 time = 5;
inline bool Header::has_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Header::set_has_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Header::clear_has_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Header::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline ::google::protobuf::int32 Header::time() const {
  return time_;
}
inline void Header::set_time(::google::protobuf::int32 value) {
  set_has_time();
  time_ = value;
}

// optional .Header.ApplyFlag push = 6;
inline bool Header::has_push() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Header::set_has_push() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Header::clear_has_push() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Header::clear_push() {
  if (push_ != NULL) push_->::Header_ApplyFlag::Clear();
  clear_has_push();
}
inline const ::Header_ApplyFlag& Header::push() const {
  return push_ != NULL ? *push_ : *default_instance_->push_;
}
inline ::Header_ApplyFlag* Header::mutable_push() {
  set_has_push();
  if (push_ == NULL) push_ = new ::Header_ApplyFlag;
  return push_;
}
inline ::Header_ApplyFlag* Header::release_push() {
  clear_has_push();
  ::Header_ApplyFlag* temp = push_;
  push_ = NULL;
  return temp;
}
inline void Header::set_allocated_push(::Header_ApplyFlag* push) {
  delete push_;
  push_ = push;
  if (push) {
    set_has_push();
  } else {
    clear_has_push();
  }
}

// optional .Header.ApplyFlag pull = 7;
inline bool Header::has_pull() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Header::set_has_pull() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Header::clear_has_pull() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Header::clear_pull() {
  if (pull_ != NULL) pull_->::Header_ApplyFlag::Clear();
  clear_has_pull();
}
inline const ::Header_ApplyFlag& Header::pull() const {
  return pull_ != NULL ? *pull_ : *default_instance_->pull_;
}
inline ::Header_ApplyFlag* Header::mutable_pull() {
  set_has_pull();
  if (pull_ == NULL) pull_ = new ::Header_ApplyFlag;
  return pull_;
}
inline ::Header_ApplyFlag* Header::release_pull() {
  clear_has_pull();
  ::Header_ApplyFlag* temp = pull_;
  pull_ = NULL;
  return temp;
}
inline void Header::set_allocated_pull(::Header_ApplyFlag* pull) {
  delete pull_;
  pull_ = pull;
  if (pull) {
    set_has_pull();
  } else {
    clear_has_pull();
  }
}

// optional .Header.KeyFlag key = 8;
inline bool Header::has_key() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Header::set_has_key() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Header::clear_has_key() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Header::clear_key() {
  if (key_ != NULL) key_->::Header_KeyFlag::Clear();
  clear_has_key();
}
inline const ::Header_KeyFlag& Header::key() const {
  return key_ != NULL ? *key_ : *default_instance_->key_;
}
inline ::Header_KeyFlag* Header::mutable_key() {
  set_has_key();
  if (key_ == NULL) key_ = new ::Header_KeyFlag;
  return key_;
}
inline ::Header_KeyFlag* Header::release_key() {
  clear_has_key();
  ::Header_KeyFlag* temp = key_;
  key_ = NULL;
  return temp;
}
inline void Header::set_allocated_key(::Header_KeyFlag* key) {
  delete key_;
  key_ = key;
  if (key) {
    set_has_key();
  } else {
    clear_has_key();
  }
}

// optional .Header.ValueFlag value = 9;
inline bool Header::has_value() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Header::set_has_value() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Header::clear_has_value() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Header::clear_value() {
  if (value_ != NULL) value_->::Header_ValueFlag::Clear();
  clear_has_value();
}
inline const ::Header_ValueFlag& Header::value() const {
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::Header_ValueFlag* Header::mutable_value() {
  set_has_value();
  if (value_ == NULL) value_ = new ::Header_ValueFlag;
  return value_;
}
inline ::Header_ValueFlag* Header::release_value() {
  clear_has_value();
  ::Header_ValueFlag* temp = value_;
  value_ = NULL;
  return temp;
}
inline void Header::set_allocated_value(::Header_ValueFlag* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
}

// optional .Header.ReplicaInfo replica_info = 10;
inline bool Header::has_replica_info() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Header::set_has_replica_info() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Header::clear_has_replica_info() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Header::clear_replica_info() {
  if (replica_info_ != NULL) replica_info_->::Header_ReplicaInfo::Clear();
  clear_has_replica_info();
}
inline const ::Header_ReplicaInfo& Header::replica_info() const {
  return replica_info_ != NULL ? *replica_info_ : *default_instance_->replica_info_;
}
inline ::Header_ReplicaInfo* Header::mutable_replica_info() {
  set_has_replica_info();
  if (replica_info_ == NULL) replica_info_ = new ::Header_ReplicaInfo;
  return replica_info_;
}
inline ::Header_ReplicaInfo* Header::release_replica_info() {
  clear_has_replica_info();
  ::Header_ReplicaInfo* temp = replica_info_;
  replica_info_ = NULL;
  return temp;
}
inline void Header::set_allocated_replica_info(::Header_ReplicaInfo* replica_info) {
  delete replica_info_;
  replica_info_ = replica_info;
  if (replica_info) {
    set_has_replica_info();
  } else {
    clear_has_replica_info();
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Header_Type>() {
  return ::Header_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_proto_2fheader_2eproto__INCLUDED
