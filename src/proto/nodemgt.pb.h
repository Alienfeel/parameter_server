// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/nodemgt.proto

#ifndef PROTOBUF_proto_2fnodemgt_2eproto__INCLUDED
#define PROTOBUF_proto_2fnodemgt_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_proto_2fnodemgt_2eproto();
void protobuf_AssignDesc_proto_2fnodemgt_2eproto();
void protobuf_ShutdownFile_proto_2fnodemgt_2eproto();

class MsgKeyRange;
class ReplicaList;
class ReplicaTo;
class ReplicaNode;
class ReplicaFrom;
class FailedNode;
class NewNode;
class NodeManagementInfo;

enum NodeManagementInfo_Command {
  NodeManagementInfo_Command_SERVER_MSG_KEY_RANGE = 1,
  NodeManagementInfo_Command_CLIENT_MSG_KEY_RANGE = 2,
  NodeManagementInfo_Command_BACKUP_NODELIST = 3,
  NodeManagementInfo_Command_NOTIFY_DEAD = 4,
  NodeManagementInfo_Command_ACTIVATE_BACKUP = 5,
  NodeManagementInfo_Command_ADD_NEW_NODE = 6,
  NodeManagementInfo_Command_SERVER_PING = 7,
  NodeManagementInfo_Command_SERVER_ACK = 8
};
bool NodeManagementInfo_Command_IsValid(int value);
const NodeManagementInfo_Command NodeManagementInfo_Command_Command_MIN = NodeManagementInfo_Command_SERVER_MSG_KEY_RANGE;
const NodeManagementInfo_Command NodeManagementInfo_Command_Command_MAX = NodeManagementInfo_Command_SERVER_ACK;
const int NodeManagementInfo_Command_Command_ARRAYSIZE = NodeManagementInfo_Command_Command_MAX + 1;

const ::google::protobuf::EnumDescriptor* NodeManagementInfo_Command_descriptor();
inline const ::std::string& NodeManagementInfo_Command_Name(NodeManagementInfo_Command value) {
  return ::google::protobuf::internal::NameOfEnum(
    NodeManagementInfo_Command_descriptor(), value);
}
inline bool NodeManagementInfo_Command_Parse(
    const ::std::string& name, NodeManagementInfo_Command* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NodeManagementInfo_Command>(
    NodeManagementInfo_Command_descriptor(), name, value);
}
// ===================================================================

class MsgKeyRange : public ::google::protobuf::Message {
 public:
  MsgKeyRange();
  virtual ~MsgKeyRange();

  MsgKeyRange(const MsgKeyRange& from);

  inline MsgKeyRange& operator=(const MsgKeyRange& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgKeyRange& default_instance();

  void Swap(MsgKeyRange* other);

  // implements Message ----------------------------------------------

  MsgKeyRange* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgKeyRange& from);
  void MergeFrom(const MsgKeyRange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 key_start = 1;
  inline bool has_key_start() const;
  inline void clear_key_start();
  static const int kKeyStartFieldNumber = 1;
  inline ::google::protobuf::int64 key_start() const;
  inline void set_key_start(::google::protobuf::int64 value);

  // required int64 key_end = 2;
  inline bool has_key_end() const;
  inline void clear_key_end();
  static const int kKeyEndFieldNumber = 2;
  inline ::google::protobuf::int64 key_end() const;
  inline void set_key_end(::google::protobuf::int64 value);

  // optional int32 node_id = 3;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 3;
  inline ::google::protobuf::int32 node_id() const;
  inline void set_node_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:MsgKeyRange)
 private:
  inline void set_has_key_start();
  inline void clear_has_key_start();
  inline void set_has_key_end();
  inline void clear_has_key_end();
  inline void set_has_node_id();
  inline void clear_has_node_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 key_start_;
  ::google::protobuf::int64 key_end_;
  ::google::protobuf::int32 node_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_proto_2fnodemgt_2eproto();
  friend void protobuf_AssignDesc_proto_2fnodemgt_2eproto();
  friend void protobuf_ShutdownFile_proto_2fnodemgt_2eproto();

  void InitAsDefaultInstance();
  static MsgKeyRange* default_instance_;
};
// -------------------------------------------------------------------

class ReplicaList : public ::google::protobuf::Message {
 public:
  ReplicaList();
  virtual ~ReplicaList();

  ReplicaList(const ReplicaList& from);

  inline ReplicaList& operator=(const ReplicaList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReplicaList& default_instance();

  void Swap(ReplicaList* other);

  // implements Message ----------------------------------------------

  ReplicaList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReplicaList& from);
  void MergeFrom(const ReplicaList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 replica_id = 1;
  inline bool has_replica_id() const;
  inline void clear_replica_id();
  static const int kReplicaIdFieldNumber = 1;
  inline ::google::protobuf::int32 replica_id() const;
  inline void set_replica_id(::google::protobuf::int32 value);

  // repeated .MsgKeyRange msg_key_ranges = 3;
  inline int msg_key_ranges_size() const;
  inline void clear_msg_key_ranges();
  static const int kMsgKeyRangesFieldNumber = 3;
  inline const ::MsgKeyRange& msg_key_ranges(int index) const;
  inline ::MsgKeyRange* mutable_msg_key_ranges(int index);
  inline ::MsgKeyRange* add_msg_key_ranges();
  inline const ::google::protobuf::RepeatedPtrField< ::MsgKeyRange >&
      msg_key_ranges() const;
  inline ::google::protobuf::RepeatedPtrField< ::MsgKeyRange >*
      mutable_msg_key_ranges();

  // @@protoc_insertion_point(class_scope:ReplicaList)
 private:
  inline void set_has_replica_id();
  inline void clear_has_replica_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::MsgKeyRange > msg_key_ranges_;
  ::google::protobuf::int32 replica_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_proto_2fnodemgt_2eproto();
  friend void protobuf_AssignDesc_proto_2fnodemgt_2eproto();
  friend void protobuf_ShutdownFile_proto_2fnodemgt_2eproto();

  void InitAsDefaultInstance();
  static ReplicaList* default_instance_;
};
// -------------------------------------------------------------------

class ReplicaTo : public ::google::protobuf::Message {
 public:
  ReplicaTo();
  virtual ~ReplicaTo();

  ReplicaTo(const ReplicaTo& from);

  inline ReplicaTo& operator=(const ReplicaTo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReplicaTo& default_instance();

  void Swap(ReplicaTo* other);

  // implements Message ----------------------------------------------

  ReplicaTo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReplicaTo& from);
  void MergeFrom(const ReplicaTo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ReplicaList replica_lists = 1;
  inline int replica_lists_size() const;
  inline void clear_replica_lists();
  static const int kReplicaListsFieldNumber = 1;
  inline const ::ReplicaList& replica_lists(int index) const;
  inline ::ReplicaList* mutable_replica_lists(int index);
  inline ::ReplicaList* add_replica_lists();
  inline const ::google::protobuf::RepeatedPtrField< ::ReplicaList >&
      replica_lists() const;
  inline ::google::protobuf::RepeatedPtrField< ::ReplicaList >*
      mutable_replica_lists();

  // @@protoc_insertion_point(class_scope:ReplicaTo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::ReplicaList > replica_lists_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_proto_2fnodemgt_2eproto();
  friend void protobuf_AssignDesc_proto_2fnodemgt_2eproto();
  friend void protobuf_ShutdownFile_proto_2fnodemgt_2eproto();

  void InitAsDefaultInstance();
  static ReplicaTo* default_instance_;
};
// -------------------------------------------------------------------

class ReplicaNode : public ::google::protobuf::Message {
 public:
  ReplicaNode();
  virtual ~ReplicaNode();

  ReplicaNode(const ReplicaNode& from);

  inline ReplicaNode& operator=(const ReplicaNode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReplicaNode& default_instance();

  void Swap(ReplicaNode* other);

  // implements Message ----------------------------------------------

  ReplicaNode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReplicaNode& from);
  void MergeFrom(const ReplicaNode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 replica_ids = 2;
  inline int replica_ids_size() const;
  inline void clear_replica_ids();
  static const int kReplicaIdsFieldNumber = 2;
  inline ::google::protobuf::int32 replica_ids(int index) const;
  inline void set_replica_ids(int index, ::google::protobuf::int32 value);
  inline void add_replica_ids(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      replica_ids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_replica_ids();

  // repeated .MsgKeyRange msg_key_ranges = 3;
  inline int msg_key_ranges_size() const;
  inline void clear_msg_key_ranges();
  static const int kMsgKeyRangesFieldNumber = 3;
  inline const ::MsgKeyRange& msg_key_ranges(int index) const;
  inline ::MsgKeyRange* mutable_msg_key_ranges(int index);
  inline ::MsgKeyRange* add_msg_key_ranges();
  inline const ::google::protobuf::RepeatedPtrField< ::MsgKeyRange >&
      msg_key_ranges() const;
  inline ::google::protobuf::RepeatedPtrField< ::MsgKeyRange >*
      mutable_msg_key_ranges();

  // @@protoc_insertion_point(class_scope:ReplicaNode)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > replica_ids_;
  ::google::protobuf::RepeatedPtrField< ::MsgKeyRange > msg_key_ranges_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_proto_2fnodemgt_2eproto();
  friend void protobuf_AssignDesc_proto_2fnodemgt_2eproto();
  friend void protobuf_ShutdownFile_proto_2fnodemgt_2eproto();

  void InitAsDefaultInstance();
  static ReplicaNode* default_instance_;
};
// -------------------------------------------------------------------

class ReplicaFrom : public ::google::protobuf::Message {
 public:
  ReplicaFrom();
  virtual ~ReplicaFrom();

  ReplicaFrom(const ReplicaFrom& from);

  inline ReplicaFrom& operator=(const ReplicaFrom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReplicaFrom& default_instance();

  void Swap(ReplicaFrom* other);

  // implements Message ----------------------------------------------

  ReplicaFrom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReplicaFrom& from);
  void MergeFrom(const ReplicaFrom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ReplicaNode replica_nodes = 1;
  inline int replica_nodes_size() const;
  inline void clear_replica_nodes();
  static const int kReplicaNodesFieldNumber = 1;
  inline const ::ReplicaNode& replica_nodes(int index) const;
  inline ::ReplicaNode* mutable_replica_nodes(int index);
  inline ::ReplicaNode* add_replica_nodes();
  inline const ::google::protobuf::RepeatedPtrField< ::ReplicaNode >&
      replica_nodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::ReplicaNode >*
      mutable_replica_nodes();

  // @@protoc_insertion_point(class_scope:ReplicaFrom)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::ReplicaNode > replica_nodes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_proto_2fnodemgt_2eproto();
  friend void protobuf_AssignDesc_proto_2fnodemgt_2eproto();
  friend void protobuf_ShutdownFile_proto_2fnodemgt_2eproto();

  void InitAsDefaultInstance();
  static ReplicaFrom* default_instance_;
};
// -------------------------------------------------------------------

class FailedNode : public ::google::protobuf::Message {
 public:
  FailedNode();
  virtual ~FailedNode();

  FailedNode(const FailedNode& from);

  inline FailedNode& operator=(const FailedNode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FailedNode& default_instance();

  void Swap(FailedNode* other);

  // implements Message ----------------------------------------------

  FailedNode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FailedNode& from);
  void MergeFrom(const FailedNode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 virutal_node_id = 1;
  inline bool has_virutal_node_id() const;
  inline void clear_virutal_node_id();
  static const int kVirutalNodeIdFieldNumber = 1;
  inline ::google::protobuf::int32 virutal_node_id() const;
  inline void set_virutal_node_id(::google::protobuf::int32 value);

  // required int32 replica_to_use = 2;
  inline bool has_replica_to_use() const;
  inline void clear_replica_to_use();
  static const int kReplicaToUseFieldNumber = 2;
  inline ::google::protobuf::int32 replica_to_use() const;
  inline void set_replica_to_use(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:FailedNode)
 private:
  inline void set_has_virutal_node_id();
  inline void clear_has_virutal_node_id();
  inline void set_has_replica_to_use();
  inline void clear_has_replica_to_use();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 virutal_node_id_;
  ::google::protobuf::int32 replica_to_use_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_proto_2fnodemgt_2eproto();
  friend void protobuf_AssignDesc_proto_2fnodemgt_2eproto();
  friend void protobuf_ShutdownFile_proto_2fnodemgt_2eproto();

  void InitAsDefaultInstance();
  static FailedNode* default_instance_;
};
// -------------------------------------------------------------------

class NewNode : public ::google::protobuf::Message {
 public:
  NewNode();
  virtual ~NewNode();

  NewNode(const NewNode& from);

  inline NewNode& operator=(const NewNode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewNode& default_instance();

  void Swap(NewNode* other);

  // implements Message ----------------------------------------------

  NewNode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NewNode& from);
  void MergeFrom(const NewNode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string server_address = 1;
  inline bool has_server_address() const;
  inline void clear_server_address();
  static const int kServerAddressFieldNumber = 1;
  inline const ::std::string& server_address() const;
  inline void set_server_address(const ::std::string& value);
  inline void set_server_address(const char* value);
  inline void set_server_address(const char* value, size_t size);
  inline ::std::string* mutable_server_address();
  inline ::std::string* release_server_address();
  inline void set_allocated_server_address(::std::string* server_address);

  // required string cmd_address = 2;
  inline bool has_cmd_address() const;
  inline void clear_cmd_address();
  static const int kCmdAddressFieldNumber = 2;
  inline const ::std::string& cmd_address() const;
  inline void set_cmd_address(const ::std::string& value);
  inline void set_cmd_address(const char* value);
  inline void set_cmd_address(const char* value, size_t size);
  inline ::std::string* mutable_cmd_address();
  inline ::std::string* release_cmd_address();
  inline void set_allocated_cmd_address(::std::string* cmd_address);

  // required .MsgKeyRange range = 3;
  inline bool has_range() const;
  inline void clear_range();
  static const int kRangeFieldNumber = 3;
  inline const ::MsgKeyRange& range() const;
  inline ::MsgKeyRange* mutable_range();
  inline ::MsgKeyRange* release_range();
  inline void set_allocated_range(::MsgKeyRange* range);

  // @@protoc_insertion_point(class_scope:NewNode)
 private:
  inline void set_has_server_address();
  inline void clear_has_server_address();
  inline void set_has_cmd_address();
  inline void clear_has_cmd_address();
  inline void set_has_range();
  inline void clear_has_range();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* server_address_;
  ::std::string* cmd_address_;
  ::MsgKeyRange* range_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_proto_2fnodemgt_2eproto();
  friend void protobuf_AssignDesc_proto_2fnodemgt_2eproto();
  friend void protobuf_ShutdownFile_proto_2fnodemgt_2eproto();

  void InitAsDefaultInstance();
  static NewNode* default_instance_;
};
// -------------------------------------------------------------------

class NodeManagementInfo : public ::google::protobuf::Message {
 public:
  NodeManagementInfo();
  virtual ~NodeManagementInfo();

  NodeManagementInfo(const NodeManagementInfo& from);

  inline NodeManagementInfo& operator=(const NodeManagementInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeManagementInfo& default_instance();

  void Swap(NodeManagementInfo* other);

  // implements Message ----------------------------------------------

  NodeManagementInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeManagementInfo& from);
  void MergeFrom(const NodeManagementInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef NodeManagementInfo_Command Command;
  static const Command SERVER_MSG_KEY_RANGE = NodeManagementInfo_Command_SERVER_MSG_KEY_RANGE;
  static const Command CLIENT_MSG_KEY_RANGE = NodeManagementInfo_Command_CLIENT_MSG_KEY_RANGE;
  static const Command BACKUP_NODELIST = NodeManagementInfo_Command_BACKUP_NODELIST;
  static const Command NOTIFY_DEAD = NodeManagementInfo_Command_NOTIFY_DEAD;
  static const Command ACTIVATE_BACKUP = NodeManagementInfo_Command_ACTIVATE_BACKUP;
  static const Command ADD_NEW_NODE = NodeManagementInfo_Command_ADD_NEW_NODE;
  static const Command SERVER_PING = NodeManagementInfo_Command_SERVER_PING;
  static const Command SERVER_ACK = NodeManagementInfo_Command_SERVER_ACK;
  static inline bool Command_IsValid(int value) {
    return NodeManagementInfo_Command_IsValid(value);
  }
  static const Command Command_MIN =
    NodeManagementInfo_Command_Command_MIN;
  static const Command Command_MAX =
    NodeManagementInfo_Command_Command_MAX;
  static const int Command_ARRAYSIZE =
    NodeManagementInfo_Command_Command_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Command_descriptor() {
    return NodeManagementInfo_Command_descriptor();
  }
  static inline const ::std::string& Command_Name(Command value) {
    return NodeManagementInfo_Command_Name(value);
  }
  static inline bool Command_Parse(const ::std::string& name,
      Command* value) {
    return NodeManagementInfo_Command_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .NodeManagementInfo.Command command_id = 1;
  inline bool has_command_id() const;
  inline void clear_command_id();
  static const int kCommandIdFieldNumber = 1;
  inline ::NodeManagementInfo_Command command_id() const;
  inline void set_command_id(::NodeManagementInfo_Command value);

  // optional .MsgKeyRange msg_key_range = 2;
  inline bool has_msg_key_range() const;
  inline void clear_msg_key_range();
  static const int kMsgKeyRangeFieldNumber = 2;
  inline const ::MsgKeyRange& msg_key_range() const;
  inline ::MsgKeyRange* mutable_msg_key_range();
  inline ::MsgKeyRange* release_msg_key_range();
  inline void set_allocated_msg_key_range(::MsgKeyRange* msg_key_range);

  // repeated .MsgKeyRange msg_key_ranges = 3;
  inline int msg_key_ranges_size() const;
  inline void clear_msg_key_ranges();
  static const int kMsgKeyRangesFieldNumber = 3;
  inline const ::MsgKeyRange& msg_key_ranges(int index) const;
  inline ::MsgKeyRange* mutable_msg_key_ranges(int index);
  inline ::MsgKeyRange* add_msg_key_ranges();
  inline const ::google::protobuf::RepeatedPtrField< ::MsgKeyRange >&
      msg_key_ranges() const;
  inline ::google::protobuf::RepeatedPtrField< ::MsgKeyRange >*
      mutable_msg_key_ranges();

  // optional .ReplicaTo replica_to = 4;
  inline bool has_replica_to() const;
  inline void clear_replica_to();
  static const int kReplicaToFieldNumber = 4;
  inline const ::ReplicaTo& replica_to() const;
  inline ::ReplicaTo* mutable_replica_to();
  inline ::ReplicaTo* release_replica_to();
  inline void set_allocated_replica_to(::ReplicaTo* replica_to);

  // optional .ReplicaFrom replica_from = 5;
  inline bool has_replica_from() const;
  inline void clear_replica_from();
  static const int kReplicaFromFieldNumber = 5;
  inline const ::ReplicaFrom& replica_from() const;
  inline ::ReplicaFrom* mutable_replica_from();
  inline ::ReplicaFrom* release_replica_from();
  inline void set_allocated_replica_from(::ReplicaFrom* replica_from);

  // optional int32 failed_node_id = 6;
  inline bool has_failed_node_id() const;
  inline void clear_failed_node_id();
  static const int kFailedNodeIdFieldNumber = 6;
  inline ::google::protobuf::int32 failed_node_id() const;
  inline void set_failed_node_id(::google::protobuf::int32 value);

  // optional .FailedNode failed_node = 7;
  inline bool has_failed_node() const;
  inline void clear_failed_node();
  static const int kFailedNodeFieldNumber = 7;
  inline const ::FailedNode& failed_node() const;
  inline ::FailedNode* mutable_failed_node();
  inline ::FailedNode* release_failed_node();
  inline void set_allocated_failed_node(::FailedNode* failed_node);

  // optional .NewNode new_node = 8;
  inline bool has_new_node() const;
  inline void clear_new_node();
  static const int kNewNodeFieldNumber = 8;
  inline const ::NewNode& new_node() const;
  inline ::NewNode* mutable_new_node();
  inline ::NewNode* release_new_node();
  inline void set_allocated_new_node(::NewNode* new_node);

  // required int32 recver = 20;
  inline bool has_recver() const;
  inline void clear_recver();
  static const int kRecverFieldNumber = 20;
  inline ::google::protobuf::int32 recver() const;
  inline void set_recver(::google::protobuf::int32 value);

  // optional string name = 21;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 21;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required int32 sender = 22;
  inline bool has_sender() const;
  inline void clear_sender();
  static const int kSenderFieldNumber = 22;
  inline ::google::protobuf::int32 sender() const;
  inline void set_sender(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:NodeManagementInfo)
 private:
  inline void set_has_command_id();
  inline void clear_has_command_id();
  inline void set_has_msg_key_range();
  inline void clear_has_msg_key_range();
  inline void set_has_replica_to();
  inline void clear_has_replica_to();
  inline void set_has_replica_from();
  inline void clear_has_replica_from();
  inline void set_has_failed_node_id();
  inline void clear_has_failed_node_id();
  inline void set_has_failed_node();
  inline void clear_has_failed_node();
  inline void set_has_new_node();
  inline void clear_has_new_node();
  inline void set_has_recver();
  inline void clear_has_recver();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_sender();
  inline void clear_has_sender();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::MsgKeyRange* msg_key_range_;
  ::google::protobuf::RepeatedPtrField< ::MsgKeyRange > msg_key_ranges_;
  int command_id_;
  ::google::protobuf::int32 failed_node_id_;
  ::ReplicaTo* replica_to_;
  ::ReplicaFrom* replica_from_;
  ::FailedNode* failed_node_;
  ::NewNode* new_node_;
  ::std::string* name_;
  ::google::protobuf::int32 recver_;
  ::google::protobuf::int32 sender_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_proto_2fnodemgt_2eproto();
  friend void protobuf_AssignDesc_proto_2fnodemgt_2eproto();
  friend void protobuf_ShutdownFile_proto_2fnodemgt_2eproto();

  void InitAsDefaultInstance();
  static NodeManagementInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// MsgKeyRange

// required int64 key_start = 1;
inline bool MsgKeyRange::has_key_start() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgKeyRange::set_has_key_start() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgKeyRange::clear_has_key_start() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgKeyRange::clear_key_start() {
  key_start_ = GOOGLE_LONGLONG(0);
  clear_has_key_start();
}
inline ::google::protobuf::int64 MsgKeyRange::key_start() const {
  return key_start_;
}
inline void MsgKeyRange::set_key_start(::google::protobuf::int64 value) {
  set_has_key_start();
  key_start_ = value;
}

// required int64 key_end = 2;
inline bool MsgKeyRange::has_key_end() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgKeyRange::set_has_key_end() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgKeyRange::clear_has_key_end() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgKeyRange::clear_key_end() {
  key_end_ = GOOGLE_LONGLONG(0);
  clear_has_key_end();
}
inline ::google::protobuf::int64 MsgKeyRange::key_end() const {
  return key_end_;
}
inline void MsgKeyRange::set_key_end(::google::protobuf::int64 value) {
  set_has_key_end();
  key_end_ = value;
}

// optional int32 node_id = 3;
inline bool MsgKeyRange::has_node_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgKeyRange::set_has_node_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgKeyRange::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgKeyRange::clear_node_id() {
  node_id_ = 0;
  clear_has_node_id();
}
inline ::google::protobuf::int32 MsgKeyRange::node_id() const {
  return node_id_;
}
inline void MsgKeyRange::set_node_id(::google::protobuf::int32 value) {
  set_has_node_id();
  node_id_ = value;
}

// -------------------------------------------------------------------

// ReplicaList

// required int32 replica_id = 1;
inline bool ReplicaList::has_replica_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReplicaList::set_has_replica_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReplicaList::clear_has_replica_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReplicaList::clear_replica_id() {
  replica_id_ = 0;
  clear_has_replica_id();
}
inline ::google::protobuf::int32 ReplicaList::replica_id() const {
  return replica_id_;
}
inline void ReplicaList::set_replica_id(::google::protobuf::int32 value) {
  set_has_replica_id();
  replica_id_ = value;
}

// repeated .MsgKeyRange msg_key_ranges = 3;
inline int ReplicaList::msg_key_ranges_size() const {
  return msg_key_ranges_.size();
}
inline void ReplicaList::clear_msg_key_ranges() {
  msg_key_ranges_.Clear();
}
inline const ::MsgKeyRange& ReplicaList::msg_key_ranges(int index) const {
  return msg_key_ranges_.Get(index);
}
inline ::MsgKeyRange* ReplicaList::mutable_msg_key_ranges(int index) {
  return msg_key_ranges_.Mutable(index);
}
inline ::MsgKeyRange* ReplicaList::add_msg_key_ranges() {
  return msg_key_ranges_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MsgKeyRange >&
ReplicaList::msg_key_ranges() const {
  return msg_key_ranges_;
}
inline ::google::protobuf::RepeatedPtrField< ::MsgKeyRange >*
ReplicaList::mutable_msg_key_ranges() {
  return &msg_key_ranges_;
}

// -------------------------------------------------------------------

// ReplicaTo

// repeated .ReplicaList replica_lists = 1;
inline int ReplicaTo::replica_lists_size() const {
  return replica_lists_.size();
}
inline void ReplicaTo::clear_replica_lists() {
  replica_lists_.Clear();
}
inline const ::ReplicaList& ReplicaTo::replica_lists(int index) const {
  return replica_lists_.Get(index);
}
inline ::ReplicaList* ReplicaTo::mutable_replica_lists(int index) {
  return replica_lists_.Mutable(index);
}
inline ::ReplicaList* ReplicaTo::add_replica_lists() {
  return replica_lists_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ReplicaList >&
ReplicaTo::replica_lists() const {
  return replica_lists_;
}
inline ::google::protobuf::RepeatedPtrField< ::ReplicaList >*
ReplicaTo::mutable_replica_lists() {
  return &replica_lists_;
}

// -------------------------------------------------------------------

// ReplicaNode

// repeated int32 replica_ids = 2;
inline int ReplicaNode::replica_ids_size() const {
  return replica_ids_.size();
}
inline void ReplicaNode::clear_replica_ids() {
  replica_ids_.Clear();
}
inline ::google::protobuf::int32 ReplicaNode::replica_ids(int index) const {
  return replica_ids_.Get(index);
}
inline void ReplicaNode::set_replica_ids(int index, ::google::protobuf::int32 value) {
  replica_ids_.Set(index, value);
}
inline void ReplicaNode::add_replica_ids(::google::protobuf::int32 value) {
  replica_ids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ReplicaNode::replica_ids() const {
  return replica_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ReplicaNode::mutable_replica_ids() {
  return &replica_ids_;
}

// repeated .MsgKeyRange msg_key_ranges = 3;
inline int ReplicaNode::msg_key_ranges_size() const {
  return msg_key_ranges_.size();
}
inline void ReplicaNode::clear_msg_key_ranges() {
  msg_key_ranges_.Clear();
}
inline const ::MsgKeyRange& ReplicaNode::msg_key_ranges(int index) const {
  return msg_key_ranges_.Get(index);
}
inline ::MsgKeyRange* ReplicaNode::mutable_msg_key_ranges(int index) {
  return msg_key_ranges_.Mutable(index);
}
inline ::MsgKeyRange* ReplicaNode::add_msg_key_ranges() {
  return msg_key_ranges_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MsgKeyRange >&
ReplicaNode::msg_key_ranges() const {
  return msg_key_ranges_;
}
inline ::google::protobuf::RepeatedPtrField< ::MsgKeyRange >*
ReplicaNode::mutable_msg_key_ranges() {
  return &msg_key_ranges_;
}

// -------------------------------------------------------------------

// ReplicaFrom

// repeated .ReplicaNode replica_nodes = 1;
inline int ReplicaFrom::replica_nodes_size() const {
  return replica_nodes_.size();
}
inline void ReplicaFrom::clear_replica_nodes() {
  replica_nodes_.Clear();
}
inline const ::ReplicaNode& ReplicaFrom::replica_nodes(int index) const {
  return replica_nodes_.Get(index);
}
inline ::ReplicaNode* ReplicaFrom::mutable_replica_nodes(int index) {
  return replica_nodes_.Mutable(index);
}
inline ::ReplicaNode* ReplicaFrom::add_replica_nodes() {
  return replica_nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ReplicaNode >&
ReplicaFrom::replica_nodes() const {
  return replica_nodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::ReplicaNode >*
ReplicaFrom::mutable_replica_nodes() {
  return &replica_nodes_;
}

// -------------------------------------------------------------------

// FailedNode

// required int32 virutal_node_id = 1;
inline bool FailedNode::has_virutal_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FailedNode::set_has_virutal_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FailedNode::clear_has_virutal_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FailedNode::clear_virutal_node_id() {
  virutal_node_id_ = 0;
  clear_has_virutal_node_id();
}
inline ::google::protobuf::int32 FailedNode::virutal_node_id() const {
  return virutal_node_id_;
}
inline void FailedNode::set_virutal_node_id(::google::protobuf::int32 value) {
  set_has_virutal_node_id();
  virutal_node_id_ = value;
}

// required int32 replica_to_use = 2;
inline bool FailedNode::has_replica_to_use() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FailedNode::set_has_replica_to_use() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FailedNode::clear_has_replica_to_use() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FailedNode::clear_replica_to_use() {
  replica_to_use_ = 0;
  clear_has_replica_to_use();
}
inline ::google::protobuf::int32 FailedNode::replica_to_use() const {
  return replica_to_use_;
}
inline void FailedNode::set_replica_to_use(::google::protobuf::int32 value) {
  set_has_replica_to_use();
  replica_to_use_ = value;
}

// -------------------------------------------------------------------

// NewNode

// required string server_address = 1;
inline bool NewNode::has_server_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewNode::set_has_server_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewNode::clear_has_server_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewNode::clear_server_address() {
  if (server_address_ != &::google::protobuf::internal::kEmptyString) {
    server_address_->clear();
  }
  clear_has_server_address();
}
inline const ::std::string& NewNode::server_address() const {
  return *server_address_;
}
inline void NewNode::set_server_address(const ::std::string& value) {
  set_has_server_address();
  if (server_address_ == &::google::protobuf::internal::kEmptyString) {
    server_address_ = new ::std::string;
  }
  server_address_->assign(value);
}
inline void NewNode::set_server_address(const char* value) {
  set_has_server_address();
  if (server_address_ == &::google::protobuf::internal::kEmptyString) {
    server_address_ = new ::std::string;
  }
  server_address_->assign(value);
}
inline void NewNode::set_server_address(const char* value, size_t size) {
  set_has_server_address();
  if (server_address_ == &::google::protobuf::internal::kEmptyString) {
    server_address_ = new ::std::string;
  }
  server_address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NewNode::mutable_server_address() {
  set_has_server_address();
  if (server_address_ == &::google::protobuf::internal::kEmptyString) {
    server_address_ = new ::std::string;
  }
  return server_address_;
}
inline ::std::string* NewNode::release_server_address() {
  clear_has_server_address();
  if (server_address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = server_address_;
    server_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NewNode::set_allocated_server_address(::std::string* server_address) {
  if (server_address_ != &::google::protobuf::internal::kEmptyString) {
    delete server_address_;
  }
  if (server_address) {
    set_has_server_address();
    server_address_ = server_address;
  } else {
    clear_has_server_address();
    server_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string cmd_address = 2;
inline bool NewNode::has_cmd_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewNode::set_has_cmd_address() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewNode::clear_has_cmd_address() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewNode::clear_cmd_address() {
  if (cmd_address_ != &::google::protobuf::internal::kEmptyString) {
    cmd_address_->clear();
  }
  clear_has_cmd_address();
}
inline const ::std::string& NewNode::cmd_address() const {
  return *cmd_address_;
}
inline void NewNode::set_cmd_address(const ::std::string& value) {
  set_has_cmd_address();
  if (cmd_address_ == &::google::protobuf::internal::kEmptyString) {
    cmd_address_ = new ::std::string;
  }
  cmd_address_->assign(value);
}
inline void NewNode::set_cmd_address(const char* value) {
  set_has_cmd_address();
  if (cmd_address_ == &::google::protobuf::internal::kEmptyString) {
    cmd_address_ = new ::std::string;
  }
  cmd_address_->assign(value);
}
inline void NewNode::set_cmd_address(const char* value, size_t size) {
  set_has_cmd_address();
  if (cmd_address_ == &::google::protobuf::internal::kEmptyString) {
    cmd_address_ = new ::std::string;
  }
  cmd_address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NewNode::mutable_cmd_address() {
  set_has_cmd_address();
  if (cmd_address_ == &::google::protobuf::internal::kEmptyString) {
    cmd_address_ = new ::std::string;
  }
  return cmd_address_;
}
inline ::std::string* NewNode::release_cmd_address() {
  clear_has_cmd_address();
  if (cmd_address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cmd_address_;
    cmd_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NewNode::set_allocated_cmd_address(::std::string* cmd_address) {
  if (cmd_address_ != &::google::protobuf::internal::kEmptyString) {
    delete cmd_address_;
  }
  if (cmd_address) {
    set_has_cmd_address();
    cmd_address_ = cmd_address;
  } else {
    clear_has_cmd_address();
    cmd_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .MsgKeyRange range = 3;
inline bool NewNode::has_range() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NewNode::set_has_range() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NewNode::clear_has_range() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NewNode::clear_range() {
  if (range_ != NULL) range_->::MsgKeyRange::Clear();
  clear_has_range();
}
inline const ::MsgKeyRange& NewNode::range() const {
  return range_ != NULL ? *range_ : *default_instance_->range_;
}
inline ::MsgKeyRange* NewNode::mutable_range() {
  set_has_range();
  if (range_ == NULL) range_ = new ::MsgKeyRange;
  return range_;
}
inline ::MsgKeyRange* NewNode::release_range() {
  clear_has_range();
  ::MsgKeyRange* temp = range_;
  range_ = NULL;
  return temp;
}
inline void NewNode::set_allocated_range(::MsgKeyRange* range) {
  delete range_;
  range_ = range;
  if (range) {
    set_has_range();
  } else {
    clear_has_range();
  }
}

// -------------------------------------------------------------------

// NodeManagementInfo

// required .NodeManagementInfo.Command command_id = 1;
inline bool NodeManagementInfo::has_command_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeManagementInfo::set_has_command_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeManagementInfo::clear_has_command_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeManagementInfo::clear_command_id() {
  command_id_ = 1;
  clear_has_command_id();
}
inline ::NodeManagementInfo_Command NodeManagementInfo::command_id() const {
  return static_cast< ::NodeManagementInfo_Command >(command_id_);
}
inline void NodeManagementInfo::set_command_id(::NodeManagementInfo_Command value) {
  assert(::NodeManagementInfo_Command_IsValid(value));
  set_has_command_id();
  command_id_ = value;
}

// optional .MsgKeyRange msg_key_range = 2;
inline bool NodeManagementInfo::has_msg_key_range() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NodeManagementInfo::set_has_msg_key_range() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NodeManagementInfo::clear_has_msg_key_range() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NodeManagementInfo::clear_msg_key_range() {
  if (msg_key_range_ != NULL) msg_key_range_->::MsgKeyRange::Clear();
  clear_has_msg_key_range();
}
inline const ::MsgKeyRange& NodeManagementInfo::msg_key_range() const {
  return msg_key_range_ != NULL ? *msg_key_range_ : *default_instance_->msg_key_range_;
}
inline ::MsgKeyRange* NodeManagementInfo::mutable_msg_key_range() {
  set_has_msg_key_range();
  if (msg_key_range_ == NULL) msg_key_range_ = new ::MsgKeyRange;
  return msg_key_range_;
}
inline ::MsgKeyRange* NodeManagementInfo::release_msg_key_range() {
  clear_has_msg_key_range();
  ::MsgKeyRange* temp = msg_key_range_;
  msg_key_range_ = NULL;
  return temp;
}
inline void NodeManagementInfo::set_allocated_msg_key_range(::MsgKeyRange* msg_key_range) {
  delete msg_key_range_;
  msg_key_range_ = msg_key_range;
  if (msg_key_range) {
    set_has_msg_key_range();
  } else {
    clear_has_msg_key_range();
  }
}

// repeated .MsgKeyRange msg_key_ranges = 3;
inline int NodeManagementInfo::msg_key_ranges_size() const {
  return msg_key_ranges_.size();
}
inline void NodeManagementInfo::clear_msg_key_ranges() {
  msg_key_ranges_.Clear();
}
inline const ::MsgKeyRange& NodeManagementInfo::msg_key_ranges(int index) const {
  return msg_key_ranges_.Get(index);
}
inline ::MsgKeyRange* NodeManagementInfo::mutable_msg_key_ranges(int index) {
  return msg_key_ranges_.Mutable(index);
}
inline ::MsgKeyRange* NodeManagementInfo::add_msg_key_ranges() {
  return msg_key_ranges_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MsgKeyRange >&
NodeManagementInfo::msg_key_ranges() const {
  return msg_key_ranges_;
}
inline ::google::protobuf::RepeatedPtrField< ::MsgKeyRange >*
NodeManagementInfo::mutable_msg_key_ranges() {
  return &msg_key_ranges_;
}

// optional .ReplicaTo replica_to = 4;
inline bool NodeManagementInfo::has_replica_to() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NodeManagementInfo::set_has_replica_to() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NodeManagementInfo::clear_has_replica_to() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NodeManagementInfo::clear_replica_to() {
  if (replica_to_ != NULL) replica_to_->::ReplicaTo::Clear();
  clear_has_replica_to();
}
inline const ::ReplicaTo& NodeManagementInfo::replica_to() const {
  return replica_to_ != NULL ? *replica_to_ : *default_instance_->replica_to_;
}
inline ::ReplicaTo* NodeManagementInfo::mutable_replica_to() {
  set_has_replica_to();
  if (replica_to_ == NULL) replica_to_ = new ::ReplicaTo;
  return replica_to_;
}
inline ::ReplicaTo* NodeManagementInfo::release_replica_to() {
  clear_has_replica_to();
  ::ReplicaTo* temp = replica_to_;
  replica_to_ = NULL;
  return temp;
}
inline void NodeManagementInfo::set_allocated_replica_to(::ReplicaTo* replica_to) {
  delete replica_to_;
  replica_to_ = replica_to;
  if (replica_to) {
    set_has_replica_to();
  } else {
    clear_has_replica_to();
  }
}

// optional .ReplicaFrom replica_from = 5;
inline bool NodeManagementInfo::has_replica_from() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NodeManagementInfo::set_has_replica_from() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NodeManagementInfo::clear_has_replica_from() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NodeManagementInfo::clear_replica_from() {
  if (replica_from_ != NULL) replica_from_->::ReplicaFrom::Clear();
  clear_has_replica_from();
}
inline const ::ReplicaFrom& NodeManagementInfo::replica_from() const {
  return replica_from_ != NULL ? *replica_from_ : *default_instance_->replica_from_;
}
inline ::ReplicaFrom* NodeManagementInfo::mutable_replica_from() {
  set_has_replica_from();
  if (replica_from_ == NULL) replica_from_ = new ::ReplicaFrom;
  return replica_from_;
}
inline ::ReplicaFrom* NodeManagementInfo::release_replica_from() {
  clear_has_replica_from();
  ::ReplicaFrom* temp = replica_from_;
  replica_from_ = NULL;
  return temp;
}
inline void NodeManagementInfo::set_allocated_replica_from(::ReplicaFrom* replica_from) {
  delete replica_from_;
  replica_from_ = replica_from;
  if (replica_from) {
    set_has_replica_from();
  } else {
    clear_has_replica_from();
  }
}

// optional int32 failed_node_id = 6;
inline bool NodeManagementInfo::has_failed_node_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NodeManagementInfo::set_has_failed_node_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NodeManagementInfo::clear_has_failed_node_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NodeManagementInfo::clear_failed_node_id() {
  failed_node_id_ = 0;
  clear_has_failed_node_id();
}
inline ::google::protobuf::int32 NodeManagementInfo::failed_node_id() const {
  return failed_node_id_;
}
inline void NodeManagementInfo::set_failed_node_id(::google::protobuf::int32 value) {
  set_has_failed_node_id();
  failed_node_id_ = value;
}

// optional .FailedNode failed_node = 7;
inline bool NodeManagementInfo::has_failed_node() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NodeManagementInfo::set_has_failed_node() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NodeManagementInfo::clear_has_failed_node() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NodeManagementInfo::clear_failed_node() {
  if (failed_node_ != NULL) failed_node_->::FailedNode::Clear();
  clear_has_failed_node();
}
inline const ::FailedNode& NodeManagementInfo::failed_node() const {
  return failed_node_ != NULL ? *failed_node_ : *default_instance_->failed_node_;
}
inline ::FailedNode* NodeManagementInfo::mutable_failed_node() {
  set_has_failed_node();
  if (failed_node_ == NULL) failed_node_ = new ::FailedNode;
  return failed_node_;
}
inline ::FailedNode* NodeManagementInfo::release_failed_node() {
  clear_has_failed_node();
  ::FailedNode* temp = failed_node_;
  failed_node_ = NULL;
  return temp;
}
inline void NodeManagementInfo::set_allocated_failed_node(::FailedNode* failed_node) {
  delete failed_node_;
  failed_node_ = failed_node;
  if (failed_node) {
    set_has_failed_node();
  } else {
    clear_has_failed_node();
  }
}

// optional .NewNode new_node = 8;
inline bool NodeManagementInfo::has_new_node() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void NodeManagementInfo::set_has_new_node() {
  _has_bits_[0] |= 0x00000080u;
}
inline void NodeManagementInfo::clear_has_new_node() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void NodeManagementInfo::clear_new_node() {
  if (new_node_ != NULL) new_node_->::NewNode::Clear();
  clear_has_new_node();
}
inline const ::NewNode& NodeManagementInfo::new_node() const {
  return new_node_ != NULL ? *new_node_ : *default_instance_->new_node_;
}
inline ::NewNode* NodeManagementInfo::mutable_new_node() {
  set_has_new_node();
  if (new_node_ == NULL) new_node_ = new ::NewNode;
  return new_node_;
}
inline ::NewNode* NodeManagementInfo::release_new_node() {
  clear_has_new_node();
  ::NewNode* temp = new_node_;
  new_node_ = NULL;
  return temp;
}
inline void NodeManagementInfo::set_allocated_new_node(::NewNode* new_node) {
  delete new_node_;
  new_node_ = new_node;
  if (new_node) {
    set_has_new_node();
  } else {
    clear_has_new_node();
  }
}

// required int32 recver = 20;
inline bool NodeManagementInfo::has_recver() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void NodeManagementInfo::set_has_recver() {
  _has_bits_[0] |= 0x00000100u;
}
inline void NodeManagementInfo::clear_has_recver() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void NodeManagementInfo::clear_recver() {
  recver_ = 0;
  clear_has_recver();
}
inline ::google::protobuf::int32 NodeManagementInfo::recver() const {
  return recver_;
}
inline void NodeManagementInfo::set_recver(::google::protobuf::int32 value) {
  set_has_recver();
  recver_ = value;
}

// optional string name = 21;
inline bool NodeManagementInfo::has_name() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void NodeManagementInfo::set_has_name() {
  _has_bits_[0] |= 0x00000200u;
}
inline void NodeManagementInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void NodeManagementInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& NodeManagementInfo::name() const {
  return *name_;
}
inline void NodeManagementInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NodeManagementInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NodeManagementInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NodeManagementInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* NodeManagementInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NodeManagementInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 sender = 22;
inline bool NodeManagementInfo::has_sender() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void NodeManagementInfo::set_has_sender() {
  _has_bits_[0] |= 0x00000400u;
}
inline void NodeManagementInfo::clear_has_sender() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void NodeManagementInfo::clear_sender() {
  sender_ = 0;
  clear_has_sender();
}
inline ::google::protobuf::int32 NodeManagementInfo::sender() const {
  return sender_;
}
inline void NodeManagementInfo::set_sender(::google::protobuf::int32 value) {
  set_has_sender();
  sender_ = value;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NodeManagementInfo_Command>() {
  return ::NodeManagementInfo_Command_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_proto_2fnodemgt_2eproto__INCLUDED
